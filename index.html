<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>3-Way 고정판 테트리스</title>
<style>
    /* (CSS는 이전 코드와 동일하게 적용합니다. 생략) */
    :root {
        --bg-color: #202028;
        --text-color: #fff;
        --accent-color: #ff00de;
        --ui-bg: #333;
    }
    body {
        background: var(--bg-color);
        color: var(--text-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        user-select: none;
    }

    h1 {
        margin: 0 0 15px 0;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 0 0 10px #fff, 0 0 20px var(--accent-color);
    }

    .main-container {
        display: flex;
        gap: 15px;
        position: relative;
    }

    .side-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 100px;
    }

    canvas {
        border: 2px solid #444;
        background-color: #000;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    }
    
    #main-canvas {
        /* 3개 판을 배치하기 위해 큰 캔버스 사용 */
        width: 600px; 
        height: 600px;
    }

    .ui-box {
        background: var(--ui-bg);
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        border: 1px solid #555;
    }

    .label { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
    .value { font-size: 1.2rem; font-weight: bold; color: var(--accent-color); }
    .controls-info { font-size: 0.75rem; color: #888; text-align: left; }
    .mini-canvas { width: 80px; height: 80px; margin: 0 auto; display: block;}

    /* 게임 오버 오버레이 */
    #game-over {
        display: none;
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85);
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
    }
    #game-over h2 { font-size: 2.5rem; color: red; margin-bottom: 10px; }
    #game-over p { font-size: 1.5rem; margin-bottom: 20px; }
    #restart-btn {
        padding: 10px 20px;
        font-size: 1.2rem;
        background: var(--accent-color);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #restart-btn:hover { background: #d900bd; }
    #t-spin-msg {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 2rem; color: yellow; font-weight: bold;
        opacity: 0; transition: opacity 0.3s; pointer-events: none;
    }
</style>
</head>
<body>

    <h1>3-Way Fixed Tetris</h1>

    <div class="main-container">
        <div class="side-panel">
            <div class="ui-box">
                <div class="label">HOLD (C)</div>
                <canvas id="hold-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box">
                <div class="label">SCORE</div>
                <div id="score" class="value">0</div>
            </div>
            <div class="ui-box">
                <div class="label">LEVEL</div>
                <div id="level" class="value">1</div>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="main-canvas" width="600" height="600"></canvas>
            <div id="t-spin-msg">T-SPIN!</div>
            <div id="game-over">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="final-score">0</span></p>
                <button id="restart-btn">다시 시작</button>
            </div>
        </div>

        <div class="side-panel">
             <div class="ui-box">
                <div class="label">NEXT</div>
                <canvas id="next-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box controls-info">
                <p>현재 방향: <span id="current-dir">Top</span></p>
                <p>좌우 방향키: 수평 이동</p>
                <p>아래 방향키: 중력 방향 하드드롭</p>
                <p>⬆️ / Z : 회전</p>
                <p>Space : 바로 놓기</p>
                <p>C / Shift : 홀드</p>
            </div>
        </div>
    </div>

<script>
// ===========================
// 1. 초기 설정 및 상수 정의
// ===========================
const canvas = document.getElementById('main-canvas');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextContext = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold-canvas');
const holdContext = holdCanvas.getContext('2d');

const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 20; // 픽셀 크기

// 캔버스 스케일 조정 (하나의 블록 크기를 픽셀로 설정)
context.scale(1, 1);
nextContext.scale(20, 20);
holdContext.scale(20, 20);

// 블록 색상 및 모양 정의 (이전 코드와 동일)
const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
const piecesStr = 'ILJOTSZ';

// 게임 상태 변수
let isGameOver = false;
let score = 0;
let level = 1;
let bag = []; 
let nextPieceType = null;
let holdPieceType = null;
let canHold = true;
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

// 3방향 관련 변수 (핵심)
const directions = ['top', 'right', 'left']; 
let turnIndex = 0;
let currentDir = directions[0];

// 3개의 독립된 게임판 (10x20)
const arenas = {
    'top': createMatrix(COLS, ROWS),
    'right': createMatrix(COLS, ROWS),
    'left': createMatrix(COLS, ROWS)
};

const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    type: null,
    dir: 'top', // 현재 블록이 속한 방향
};

// ===========================
// 2. 핵심 헬퍼 함수들 (재정의)
// ===========================

function createPiece(type) {
    // T, I, O, L, J, S, Z 블록 정의
    switch (type) {
        case 'I': return [[0,0,0,0],[2,2,2,2],[0,0,0,0],[0,0,0,0]];
        case 'L': return [[0,0,5],[5,5,5],[0,0,0]];
        case 'J': return [[7,0,0],[7,7,7],[0,0,0]];
        case 'O': return [[6,6],[6,6]];
        case 'Z': return [[1,1,0],[0,1,1],[0,0,0]];
        case 'S': return [[0,3,3],[3,3,0],[0,0,0]];
        case 'T': return [[0,4,0],[4,4,4],[0,0,0]];
    }
}

function createMatrix(w, h) {
    const matrix = [];
    while (h--) matrix.push(new Array(w).fill(0));
    return matrix;
}

// 매트릭스 회전 (시계 방향)
function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
}

// 충돌 감지 (현재 활성화된 arena 사용)
function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0) {
                const ay = y + o.y;
                const ax = x + o.x;
                // 바닥이나 벽 충돌
                if (ax < 0 || ax >= COLS || ay >= ROWS) return true;
                // 다른 블록 충돌
                if (arena[ay] && arena[ay][ax] !== 0) return true;
            }
        }
    }
    return false;
}

// 매트릭스 병합
function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                arena[y + player.pos.y][x + player.pos.x] = value;
            }
        });
    });
}

// 줄 삭제 및 이동 (방향별 로직)
function arenaSweep(arenaKey) {
    const arena = arenas[arenaKey];
    let rowCount = 0;

    if (arenaKey === 'top') {
        // 1. 일반적인 테트리스 (위 -> 아래, 행 삭제)
        outer: for (let y = ROWS - 1; y >= 0; --y) {
            for (let x = 0; x < COLS; ++x) {
                if (arena[y][x] === 0) continue outer;
            }
            const row = arena.splice(y, 1)[0].fill(0);
            arena.unshift(row); // 윗부분으로 밀어넣기 (아래로 당겨짐)
            ++y;
            rowCount++;
        }
    } else {
        // 2. 좌우 방향 (왼쪽/오른쪽 -> 중앙, 열 삭제 및 밀기)
        for (let x = 0; x < COLS; ++x) {
            let colFull = true;
            for (let y = 0; y < ROWS; ++y) {
                if (arena[y][x] === 0) {
                    colFull = false;
                    break;
                }
            }

            if (colFull) {
                // 열 삭제 및 블록 밀기
                for (let j = x; j > 0; --j) {
                    for (let i = 0; i < ROWS; ++i) {
                        arena[i][j] = arena[i][j - 1];
                    }
                }
                for (let i = 0; i < ROWS; ++i) {
                     // 가장자리 빈 열 채우기 (새 열이 들어오는 방향)
                    arena[i][0] = 0; 
                }
                rowCount++;
            }
        }
    }

    if (rowCount > 0) {
        score += rowCount * 100 * level;
        updateScoreBox();
        level = Math.floor(score / 500) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
    }
}

// ===========================
// 3. 렌더링 (고정된 판에 회전된 블록 그리기)
// ===========================

// 메인 그리기 함수
function draw() {
    context.fillStyle = '#202028';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // 3개의 독립된 판을 캔버스에 배치
    drawArena(arenas['top'], {x: 10 * BLOCK_SIZE, y: 0 * BLOCK_SIZE}, 0, 'Top');
    drawArena(arenas['right'], {x: 40 * BLOCK_SIZE, y: 20 * BLOCK_SIZE}, 90 * Math.PI / 180, 'Right');
    drawArena(arenas['left'], {x: 20 * BLOCK_SIZE, y: 40 * BLOCK_SIZE}, -90 * Math.PI / 180, 'Left');
    
    // 활성화된 블록 그리기
    drawPlayer();
}

// 개별 Arena 그리기
function drawArena(arena, offset, rotation, key) {
    context.save();
    
    // 중앙점 이동 및 회전
    context.translate(offset.x, offset.y);
    context.rotate(rotation);
    
    // 캔버스 중앙에 오도록 추가 보정 (회전된 보드를 정렬)
    let translateX = 0;
    let translateY = 0;
    if (key === 'Right') {
        translateX = COLS * BLOCK_SIZE;
    } else if (key === 'Left') {
        translateY = ROWS * BLOCK_SIZE;
    }
    context.translate(translateX, translateY);


    // 배경 및 경계선
    context.fillStyle = '#111';
    context.fillRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
    context.strokeStyle = '#555';
    context.strokeRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
    
    // 고정된 블록 그리기
    drawMatrix(context, arena, {x: 0, y: 0}, BLOCK_SIZE);

    context.restore();
}

// 현재 플레이어 블록 그리기
function drawPlayer() {
    const arenaKey = player.dir;
    const offset = {x: 0, y: 0};
    let rotation = 0;
    
    // 위치 및 회전 설정 (drawArena와 동일)
    if (arenaKey === 'top') {
        offset.x = 10 * BLOCK_SIZE;
        offset.y = 0 * BLOCK_SIZE;
    } else if (arenaKey === 'right') {
        offset.x = 40 * BLOCK_SIZE;
        offset.y = 20 * BLOCK_SIZE;
        rotation = 90 * Math.PI / 180;
    } else if (arenaKey === 'left') {
        offset.x = 20 * BLOCK_SIZE;
        offset.y = 40 * BLOCK_SIZE;
        rotation = -90 * Math.PI / 180;
    }

    context.save();
    context.translate(offset.x, offset.y);
    context.rotate(rotation);
    
    // 캔버스 중앙 보정 (drawArena와 동일)
    let translateX = 0;
    let translateY = 0;
    if (arenaKey === 'right') {
        translateX = COLS * BLOCK_SIZE;
    } else if (arenaKey === 'left') {
        translateY = ROWS * BLOCK_SIZE;
    }
    context.translate(translateX, translateY);

    // 플레이어 블록을 해당 캔버스 위치에 그리기
    const pos = player.pos;
    drawMatrix(context, player.matrix, pos, BLOCK_SIZE);

    context.restore();
}

// 행렬 그리기 유틸리티
function drawMatrix(ctx, matrix, offset, scale) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                ctx.fillStyle = colors[value];
                ctx.fillRect((x + offset.x) * scale, (y + offset.y) * scale, scale, scale);
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.strokeRect((x + offset.x) * scale, (y + offset.y) * scale, scale, scale);
            }
        });
    });
}

// ===========================
// 4. 플레이어 조작 및 게임 흐름 (방향별 조작 적용)
// ===========================

function playerDrop() {
    const arena = arenas[player.dir];
    
    // 중력 방향으로 이동
    if (player.dir === 'top') player.pos.y++;
    else if (player.dir === 'right') player.pos.x--; // 오른쪽 판은 왼쪽으로 떨어짐 (X-)
    else if (player.dir === 'left') player.pos.x++; // 왼쪽 판은 오른쪽으로 떨어짐 (X+)
    
    if (collide(arena, player)) {
        // 충돌 시 한 칸 되돌리기
        if (player.dir === 'top') player.pos.y--;
        else if (player.dir === 'right') player.pos.x++;
        else if (player.dir === 'left') player.pos.x--;
        
        merge(arena, player);
        arenaSweep(player.dir);
        playerReset(); // 다음 턴, 다음 방향으로 전환
    }
    dropCounter = 0;
}

function playerMove(dir) {
    const arena = arenas[player.dir];
    const oldX = player.pos.x;
    const oldY = player.pos.y;
    
    // 조작: 좌우 방향키는 항상 수평 이동 (중력에 수직)
    if (player.dir === 'top') {
        player.pos.x += dir; // X축 이동
    } else if (player.dir === 'right' || player.dir === 'left') {
        player.pos.y += dir; // Y축 이동
    }
    
    if (collide(arena, player)) {
        player.pos.x = oldX;
        player.pos.y = oldY;
    }
}

function playerRotate(dir) {
    const arena = arenas[player.dir];
    const oldX = player.pos.x;
    const oldY = player.pos.y;
    // T-Spin 감지를 위한 T-Spin 관련 로직은 생략되었습니다. (복잡도 한계)
    
    rotate(player.matrix, dir);
    if (collide(arena, player)) {
         // 충돌 시 벽차기 대신 단순 되돌리기
        rotate(player.matrix, -dir);
        player.pos.x = oldX;
        player.pos.y = oldY;
    }
}

function playerHardDrop() {
    const arena = arenas[player.dir];
    while (!collide(arena, player)) {
        // 중력 방향으로 계속 이동
        if (player.dir === 'top') player.pos.y++;
        else if (player.dir === 'right') player.pos.x--;
        else if (player.dir === 'left') player.pos.x++;
    }
    // 마지막 이동 되돌리기
    if (player.dir === 'top') player.pos.y--;
    else if (player.dir === 'right') player.pos.x++;
    else if (player.dir === 'left') player.pos.x--;

    merge(arena, player);
    arenaSweep(player.dir);
    playerReset();
}

function getNextPiece() {
    // 7-Bag 시스템
    if (bag.length === 0) {
        bag = piecesStr.split('').sort(() => Math.random() - 0.5);
    }
    return bag.pop();
}

function playerHold() {
    if (!canHold) return;
    
    if (holdPieceType === null) {
        holdPieceType = player.type;
        playerReset(false); 
    } else {
        const temp = player.type;
        player.type = holdPieceType;
        holdPieceType = temp;
        player.matrix = createPiece(player.type);
        // 홀드 후 블록 위치 재설정
        player.pos.y = 0;
        player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);
    }
    canHold = false;
    drawMiniCanvas(holdContext, holdPieceType, 1);
}

// 블록 리셋 및 턴 변경 (다음 방향으로 순환)
function playerReset(changeTurn = true) {
    if (nextPieceType === null) nextPieceType = getNextPiece();
    
    player.type = nextPieceType;
    nextPieceType = getNextPiece();
    
    if (changeTurn) {
        turnIndex++;
        player.dir = directions[turnIndex % 3]; // 방향 순환
        canHold = true;
        document.getElementById('current-dir').innerText = player.dir.toUpperCase();
    }
    
    // 블록 매트릭스 생성 및 방향에 따라 90도 회전
    player.matrix = createPiece(player.type);
    if (player.dir !== 'top') {
        // 좌우 방향 블록은 90도 회전된 형태로 나옴
        rotate(player.matrix, 1); 
    }

    // 위치 초기화 (항상 상단 중앙에서 시작)
    player.pos.y = 0;
    player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);

    drawMiniCanvas(nextContext, nextPieceType, player.dir === 'top' ? 1 : 1);
    drawMiniCanvas(holdContext, holdPieceType, 1);

    // 게임 오버 체크 (새 블록이 나올 자리에 이미 블록이 있다면)
    if (collide(arenas[player.dir], player)) {
        gameOver();
    }
}

function gameOver() {
    isGameOver = true;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over').style.display = 'flex';
}

function restartGame() {
    // 모든 판 초기화
    for (const key in arenas) {
        arenas[key].forEach(row => row.fill(0));
    }
    score = 0;
    level = 1;
    turnIndex = 0;
    bag = [];
    nextPieceType = null;
    holdPieceType = null;
    isGameOver = false;
    dropInterval = 1000;
    updateScoreBox();
    drawMiniCanvas(holdContext, null, 1);
    document.getElementById('game-over').style.display = 'none';
    playerReset();
    update();
}

function updateScoreBox() {
    document.getElementById('score').innerText = score;
    document.getElementById('level').innerText = level;
}

// 게임 루프
function update(time = 0) {
    if (isGameOver) return;

    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        playerDrop();
    }

    draw();
    requestAnimationFrame(update);
}

// 키보드 입력
document.addEventListener('keydown', event => {
    if (isGameOver) return;
    
    switch(event.keyCode) {
        case 37: playerMove(-1); break; // Left (수평 이동)
        case 39: playerMove(1); break;  // Right (수평 이동)
        case 40: playerHardDrop(); break; // Down (중력 방향 하드 드롭)
        case 38: playerRotate(1); break; // Up (Rotate CW)
        case 90: playerRotate(-1); break; // Z (Rotate CCW)
        case 32: playerHardDrop(); break; // Space (하드 드롭)
        case 67: case 16: playerHold(); break; // C or Shift (홀드)
    }
});

document.getElementById('restart-btn').addEventListener('click', restartGame);

// 게임 시작
playerReset();
update();

</script>
</body>
</html>
