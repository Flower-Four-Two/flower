<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>3-Way Ultimate Tetris</title>
<style>
    :root {
        --bg-color: #202028;
        --text-color: #fff;
        --accent-color: #ff00de;
        --ui-bg: #333;
    }
    body {
        background: var(--bg-color);
        color: var(--text-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        user-select: none;
    }

    h1 {
        margin: 0 0 15px 0;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 0 0 10px #fff, 0 0 20px var(--accent-color);
    }

    .main-container {
        display: flex;
        gap: 15px;
        position: relative;
    }

    .side-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 100px;
    }

    canvas {
        border: 2px solid #444;
        background-color: #000;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    }
    
    #main-canvas {
        /* 3방향 회전을 위해 정사각형 캔버스 사용 */
        width: 400px;
        height: 400px;
    }

    .ui-box {
        background: var(--ui-bg);
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        border: 1px solid #555;
    }

    .label { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
    .value { font-size: 1.2rem; font-weight: bold; color: var(--accent-color); }
    .controls-info { font-size: 0.75rem; color: #888; text-align: left; }
    .mini-canvas { width: 80px; height: 80px; margin: 0 auto; display: block;}

    /* 게임 오버 오버레이 */
    #game-over {
        display: none;
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85);
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
    }
    #game-over h2 { font-size: 2.5rem; color: red; margin-bottom: 10px; }
    #game-over p { font-size: 1.5rem; margin-bottom: 20px; }
    #restart-btn {
        padding: 10px 20px;
        font-size: 1.2rem;
        background: var(--accent-color);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #restart-btn:hover { background: #d900bd; }
    #t-spin-msg {
        position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
        font-size: 2rem; color: yellow; font-weight: bold;
        opacity: 0; transition: opacity 0.3s; pointer-events: none;
    }
</style>
</head>
<body>

    <h1>3-Way Tetris</h1>

    <div class="main-container">
        <div class="side-panel">
            <div class="ui-box">
                <div class="label">HOLD (C)</div>
                <canvas id="hold-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box">
                <div class="label">SCORE</div>
                <div id="score" class="value">0</div>
            </div>
            <div class="ui-box">
                <div class="label">LEVEL</div>
                <div id="level" class="value">1</div>
            </div>
        </div>

        <div style="position: relative;">
             <canvas id="main-canvas" width="400" height="400"></canvas>
            <div id="t-spin-msg">T-SPIN!</div>
            <div id="game-over">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="final-score">0</span></p>
                <button id="restart-btn">다시 시작</button>
            </div>
        </div>

        <div class="side-panel">
             <div class="ui-box">
                <div class="label">NEXT</div>
                <canvas id="next-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box controls-info">
                <p>⬅️⬇️➡️ : 이동</p>
                <p>⬆️ / Z : 회전</p>
                <p>Space : 하드드롭</p>
                <p>C / Shift : 홀드</p>
            </div>
        </div>
    </div>

<script>
// ===========================
// 1. 초기 설정 및 상수 정의
// ===========================
const canvas = document.getElementById('main-canvas');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextContext = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold-canvas');
const holdContext = holdCanvas.getContext('2d');

const GRID_SIZE = 20; // 3방향 회전을 위해 20x20 정사각형 그리드 사용
const SCALE = canvas.width / GRID_SIZE;
context.scale(SCALE, SCALE);
nextContext.scale(20, 20);
holdContext.scale(20, 20);

// 블록 색상 및 모양 정의
const colors = [
    null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'
];
const piecesStr = 'ILJOTSZ';

// 게임 상태 변수
let arena = createMatrix(GRID_SIZE, GRID_SIZE);
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let isGameOver = false;
let score = 0;
let level = 1;
let bag = []; // 7-bag 시스템을 위한 배열
let nextPieceType = null;
let holdPieceType = null;
let canHold = true;
let lastMoveWasRotate = false; // T-spin 감지용

// 3방향 관련 변수
const directions = ['top', 'right', 'left']; // 순서: 위 -> 오른쪽 -> 왼쪽
let turnIndex = 0;
let currentDir = directions[0];

const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    type: null
};

// ===========================
// 2. 핵심 헬퍼 함수들
// ===========================

// 블록 모양 생성
function createPiece(type) {
    switch (type) {
        case 'I': return [[0,0,0,0],[2,2,2,2],[0,0,0,0],[0,0,0,0]];
        case 'L': return [[0,0,5],[5,5,5],[0,0,0]];
        case 'J': return [[7,0,0],[7,7,7],[0,0,0]];
        case 'O': return [[6,6],[6,6]];
        case 'Z': return [[1,1,0],[0,1,1],[0,0,0]];
        case 'S': return [[0,3,3],[3,3,0],[0,0,0]];
        case 'T': return [[0,4,0],[4,4,4],[0,0,0]];
    }
}

// 매트릭스 생성 (게임 보드)
function createMatrix(w, h) {
    const matrix = [];
    while (h--) matrix.push(new Array(w).fill(0));
    return matrix;
}

// 충돌 감지
function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 &&
               (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                return true;
            }
        }
    }
    return false;
}

// 매트릭스 병합 (블록 고정)
function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                arena[y + player.pos.y][x + player.pos.x] = value;
            }
        });
    });
}

// 매트릭스 회전
function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
}

// 7-Bag 시스템 (블록 랜덤 생성)
function getNextPiece() {
    if (bag.length === 0) {
        bag = piecesStr.split('').sort(() => Math.random() - 0.5);
    }
    return bag.pop();
}

// T-Spin 감지
function checkTSpin(movedX, movedY) {
    if (player.type !== 'T' || !lastMoveWasRotate) return false;

    let corners = 0;
    // T 블록 중심 기준 4개의 모서리 확인
    const checks = [[0,0], [2,0], [0,2], [2,2]]; 
    checks.forEach(([cx, cy]) => {
        const ax = player.pos.x + cx;
        const ay = player.pos.y + cy;
        // 벽이거나 다른 블록이 있으면 카운트
        if (ax < 0 || ax >= GRID_SIZE || ay >= GRID_SIZE || (arena[ay] && arena[ay][ax])) {
            corners++;
        }
    });

    // 3개 이상의 모서리가 막혀있으면 T-Spin 인정
    if (corners >= 3) {
        showTSpinEffect();
        return true;
    }
    return false;
}

// T-Spin 효과 표시
function showTSpinEffect() {
    const msg = document.getElementById('t-spin-msg');
    msg.style.opacity = 1;
    setTimeout(() => { msg.style.opacity = 0; }, 1000);
}

// ===========================
// 3. 게임 로직 및 렌더링
// ===========================

// 줄 삭제 및 점수 계산
function arenaSweep() {
    let rowCount = 0;
    outer: for (let y = arena.length - 1; y >= 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) continue outer;
        }
        // 줄이 꽉 찼을 때
        const row = arena.splice(y, 1)[0].fill(0);
        
        // *** 3방향 핵심 로직: 턴에 따라 줄이 사라지는 방향 결정 ***
        if (currentDir === 'top') {
             arena.unshift(row); // 위에서 아래로 (기존 방식)
             ++y;
        } else if (currentDir === 'right') {
            arena.push(row); // 오른쪽에서 왼쪽으로 밀림 (시각적)
             // y는 그대로 두어 다음 줄 검사
        } else if (currentDir === 'left') {
             arena.unshift(row); // 왼쪽에서 오른쪽으로 밀림 (시각적)
             ++y;
        }
        rowCount++;
    }

    if (rowCount > 0) {
        let tSpin = checkTSpin(0,0);
        // 점수 계산 (T-spin 보너스 포함)
        let baseScore = [0, 100, 300, 500, 800][rowCount] || 0;
        if (tSpin) baseScore *= (rowCount + 1); // 단순 계산
        
        score += baseScore * level;
        updateScoreBox();
        // 레벨업 (500점 마다)
        level = Math.floor(score / 500) + 1;
        dropInterval = Math.max(100, 1000 - (level-1) * 100);
    }
    lastMoveWasRotate = false;
}


// 메인 그리기 함수 (캔버스 회전 적용)
function draw() {
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // 캔버스 상태 저장 (회전 전)
    context.save();
    
    // *** 3방향 핵심: 캔버스 전체를 턴에 맞춰 회전 ***
    // 캔버스 중심으로 이동 -> 회전 -> 다시 원위치
    context.translate(GRID_SIZE/2, GRID_SIZE/2);
    if (currentDir === 'right') context.rotate(-Math.PI / 2);
    else if (currentDir === 'left') context.rotate(Math.PI / 2);
    context.translate(-GRID_SIZE/2, -GRID_SIZE/2);

    // 회전된 상태에서 아레나와 플레이어 그리기
    drawMatrix(context, arena, {x: 0, y: 0});
    drawMatrix(context, player.matrix, player.pos);

    // 캔버스 상태 복구
    context.restore();
}

// 보조 캔버스 그리기 (Next/Hold)
function drawMiniCanvas(ctx, pieceType) {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, 4, 4);
    if (pieceType) {
        const matrix = createPiece(pieceType);
        // 중앙 정렬을 위한 오프셋 계산
        const offsetX = (4 - matrix[0].length) / 2;
        const offsetY = (4 - matrix.length) / 2;
        drawMatrix(ctx, matrix, {x: offsetX, y: offsetY});
    }
}

// 행렬 그리기 유틸리티
function drawMatrix(ctx, matrix, offset) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                ctx.fillStyle = colors[value];
                ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                ctx.lineWidth = 0.05;
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
            }
        });
    });
}


// ===========================
// 4. 플레이어 조작 및 게임 흐름
// ===========================

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        playerReset(); // 다음 턴으로 넘어감
    }
    dropCounter = 0;
    lastMoveWasRotate = false;
}

function playerHardDrop() {
    while (!collide(arena, player)) {
        player.pos.y++;
    }
    player.pos.y--;
    merge(arena, player);
    arenaSweep();
    playerReset();
}

function playerMove(dir) {
    player.pos.x += dir;
    if (collide(arena, player)) {
        player.pos.x -= dir;
    }
    lastMoveWasRotate = false;
}

function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    // 벽 차기 (Wall Kick) - 단순 구현
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
        }
    }
    lastMoveWasRotate = true;
}

function playerHold() {
    if (!canHold) return;
    
    if (holdPieceType === null) {
        holdPieceType = player.type;
        playerReset(false); // 턴 넘기지 않고 새 블록
    } else {
        const temp = player.type;
        player.type = holdPieceType;
        holdPieceType = temp;
        player.matrix = createPiece(player.type);
        player.pos.y = 0;
        player.pos.x = (GRID_SIZE / 2 | 0) - (player.matrix[0].length / 2 | 0);
    }
    canHold = false;
    drawMiniCanvas(holdContext, holdPieceType);
}

// 블록 리셋 및 턴 변경 (핵심)
function playerReset(changeTurn = true) {
    if (nextPieceType === null) nextPieceType = getNextPiece();
    
    player.type = nextPieceType;
    player.matrix = createPiece(player.type);
    nextPieceType = getNextPiece();
    drawMiniCanvas(nextContext, nextPieceType);

    // 위치 초기화 (항상 상단 중앙에서 시작 - 캔버스가 회전하므로)
    player.pos.y = 0;
    player.pos.x = (GRID_SIZE / 2 | 0) - (player.matrix[0].length / 2 | 0);
    
    if (changeTurn) {
        currentDir = directions[turnIndex % 3];
        turnIndex++;
        canHold = true;
    }

    // 게임 오버 체크
    if (collide(arena, player)) {
        gameOver();
    }
}

function gameOver() {
    isGameOver = true;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over').style.display = 'flex';
}

function restartGame() {
    arena.forEach(row => row.fill(0));
    score = 0;
    level = 1;
    turnIndex = 0;
    bag = [];
    nextPieceType = null;
    holdPieceType = null;
    isGameOver = false;
    dropInterval = 1000;
    updateScoreBox();
    drawMiniCanvas(holdContext, null);
    document.getElementById('game-over').style.display = 'none';
    playerReset();
    update();
}

function updateScoreBox() {
    document.getElementById('score').innerText = score;
    document.getElementById('level').innerText = level;
}

// 게임 루프
function update(time = 0) {
    if (isGameOver) return;

    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        playerDrop();
    }

    draw();
    requestAnimationFrame(update);
}

// 키보드 입력
document.addEventListener('keydown', event => {
    if (isGameOver) return;
    
    switch(event.keyCode) {
        case 37: playerMove(-1); break; // Left
        case 39: playerMove(1); break;  // Right
        case 40: playerDrop(); break;   // Down
        case 38: playerRotate(1); break; // Up (Rotate CW)
        case 90: playerRotate(-1); break; // Z (Rotate CCW)
        case 32: playerHardDrop(); break; // Space
        case 67: case 16: playerHold(); break; // C or Shift
    }
});

document.getElementById('restart-btn').addEventListener('click', restartGame);

// 게임 시작
playerReset();
update();

</script>
</body>
</html>
