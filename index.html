<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>T-Shape 3-Way Tetris</title>
<style>
    /* -------------------
       CSS STYLES
       ------------------- */
    :root {
        --bg-color: #202028;
        --text-color: #fff;
        --accent-color: #ff00de;
        --ui-bg: #333;
    }
    body {
        background: var(--bg-color);
        color: var(--text-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        user-select: none;
    }
    h1 {
        margin: 0 0 15px 0;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 0 0 10px #fff, 0 0 20px var(--accent-color);
    }
    .main-container {
        display: flex;
        gap: 15px;
        position: relative;
    }
    .side-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 100px;
    }
    canvas {
        border: 2px solid #444;
        background-color: #000;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    }
    #main-canvas {
        width: 500px; 
        height: 400px;
    }
    .ui-box {
        background: var(--ui-bg);
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        border: 1px solid #555;
    }
    .label { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
    .value { font-size: 1.2rem; font-weight: bold; color: var(--accent-color); }
    .controls-info { font-size: 0.75rem; color: #888; text-align: left; }
    .mini-canvas { width: 80px; height: 80px; margin: 0 auto; display: block;}
    
    /* 시작 화면 및 오버레이 */
    #overlay, #game-over {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        backdrop-filter: blur(2px);
        text-align: center;
    }
    #game-over { display: none; }
    #start-btn, #restart-btn {
        padding: 15px 30px;
        font-size: 1.5rem;
        background: var(--accent-color);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 20px;
        transition: background 0.3s;
    }
    #start-btn:hover, #restart-btn:hover { background: #d900bd; }
    #game-over h2 { font-size: 3rem; color: red; margin-bottom: 10px; }
    #t-spin-msg {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 2rem; color: yellow; font-weight: bold;
        opacity: 0; transition: opacity 0.3s; pointer-events: none;
        z-index: 50;
    }
</style>
</head>
<body>

    <h1>T-Shape 3-Way Tetris</h1>

    <div class="main-container">
        <div class="side-panel">
            <div class="ui-box">
                <div class="label">HOLD (C)</div>
                <canvas id="hold-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box">
                <div class="label">SCORE</div>
                <div id="score" class="value">0</div>
            </div>
            <div class="ui-box">
                <div class="label">LEVEL</div>
                <div id="level" class="value">1</div>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="main-canvas" width="500" height="400"></canvas>
            
            <div id="overlay">
                <h2>T자형 3방향 테트리스</h2>
                <button id="start-btn">게임 시작</button>
            </div>

            <div id="t-spin-msg">T-SPIN!</div>
            <div id="game-over">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="final-score">0</span></p>
                <button id="restart-btn">다시 시작</button>
            </div>
        </div>

        <div class="side-panel">
             <div class="ui-box">
                <div class="label">NEXT</div>
                <canvas id="next-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box controls-info">
                <p>현재 방향: <span id="current-dir">TOP</span></p>
                <p>⬅️ ➡️ : 수평 이동 (중력 수직)</p>
                <p>⬇️ : 소프트 드롭</p>
                <p>Space : 하드 드롭</p>
                <p>⬆️ / Z : 회전</p>
                <p>C / Shift : 홀드</p>
            </div>
        </div>
    </div>

<script>
// ===========================
// 1. 초기 설정 및 상수 정의
// ===========================
const canvas = document.getElementById('main-canvas');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextContext = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold-canvas');
const holdContext = holdCanvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start-btn');

const GRID_COLS = 50;
const GRID_ROWS = 40;
const BLOCK_SIZE = 10; 

context.scale(BLOCK_SIZE, BLOCK_SIZE);
nextContext.scale(20, 20);
holdContext.scale(20, 20);

const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
const piecesStr = 'ILJOTSZ';
const WALL = -1; 

let isGameOver = true; // 초기에는 게임오버 상태 (시작 버튼 대기)
let score = 0;
let level = 1;
let bag = []; 
let nextPieceType = null;
let holdPieceType = null;
let canHold = true;
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let gameStarted = false;

const directions = ['top', 'right', 'left']; 
let turnIndex = 0;
let currentDir = directions[0];
let arena; // 맵 매트릭스

const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    type: null,
    dir: 'top', 
};

// ===========================
// 2. 핵심 헬퍼 함수들
// ===========================

function createPiece(type) {
    switch (type) {
        case 'I': return [[0,0,0,0],[2,2,2,2],[0,0,0,0],[0,0,0,0]];
        case 'L': return [[0,0,5],[5,5,5],[0,0,0]];
        case 'J': return [[7,0,0],[7,7,7],[0,0,0]];
        case 'O': return [[6,6],[6,6]];
        case 'Z': return [[1,1,0],[0,1,1],[0,0,0]];
        case 'S': return [[0,3,3],[3,3,0],[0,0,0]];
        case 'T': return [[0,4,0],[4,4,4],[0,0,0]];
    }
}

// 50x40 매트릭스 생성 및 'T'자 모양 유효 영역 설정 (0)
function createMatrix(w, h, fillValue) {
    const matrix = [];
    for (let y = 0; y < h; ++y) {
        matrix.push(new Array(w).fill(fillValue));
    }
    
    // T자 모양 유효 영역 (ㅗ를 180도 돌린 모양)
    
    // 1. Top Arm (10x30): X=20~29, Y=0~29
    for (let y = 0; y < 30; ++y) {
        for (let x = 20; x < 30; ++x) {
            matrix[y][x] = 0;
        }
    }
    // 2. Left Arm (20x10): X=0~19, Y=20~29
    for (let y = 20; y < 30; ++y) {
        for (let x = 0; x < 20; ++x) {
            matrix[y][x] = 0;
        }
    }
    // 3. Right Arm (20x10): X=30~49, Y=20~29
    for (let y = 20; y < 30; ++y) {
        for (let x = 30; x < 50; ++x) {
            matrix[y][x] = 0;
        }
    }
    // **수정된 코어 영역** (Y=20~29)
    
    return matrix;
}

function rotate(matrix, dir) { 
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
}

function collide(arena, player) { 
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0) {
                const ax = x + o.x;
                const ay = y + o.y;

                if (ax < 0 || ax >= GRID_COLS || ay < 0 || ay >= GRID_ROWS) return true;
                
                // 벽(-1) 또는 다른 블록(>0) 충돌
                if (arena[ay][ax] === WALL || arena[ay][ax] > 0) return true;
            }
        }
    }
    return false;
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                arena[y + player.pos.y][x + player.pos.x] = value;
            }
        });
    });
}

function arenaSweep() {
    let linesCleared = 0;
    const scoreMultiplier = 100; // T-Spin 로직은 복잡성 때문에 생략

    // 1. Top Arm (X=20~29, Y=0~29) - 행(Row) 클리어 (중력: 아래)
    for (let y = 29; y >= 0; --y) {
        let isFull = true;
        for (let x = 20; x < 30; ++x) {
            if (arena[y][x] <= 0) { isFull = false; break; }
        }
        if (isFull) {
            for (let j = y; j > 0; --j) {
                for (let x = 20; x < 30; ++x) { arena[j][x] = arena[j-1][x]; }
            }
            for (let x = 20; x < 30; ++x) { arena[0][x] = 0; }
            linesCleared++;
            y++; 
        }
    }
    
    // 2. Right Arm (X=30~49, Y=20~29) - 열(Column) 클리어 (중력: 왼쪽 -> 밀기: 오른쪽)
    for (let x = 49; x >= 30; --x) {
        let isFull = true;
        for (let y = 20; y < 30; ++y) {
            if (arena[y][x] <= 0) { isFull = false; break; }
        }
        if (isFull) {
            for (let j = x; j > 30; --j) {
                for (let y = 20; y < 30; ++y) { arena[y][j] = arena[y][j-1]; }
            }
            for (let y = 20; y < 30; ++y) { arena[y][30] = 0; }
            linesCleared++;
            x++; 
        }
    }

    // 3. Left Arm (X=0~19, Y=20~29) - 열(Column) 클리어 (중력: 오른쪽 -> 밀기: 왼쪽)
    for (let x = 0; x < 20; ++x) {
        let isFull = true;
        for (let y = 20; y < 30; ++y) {
            if (arena[y][x] <= 0) { isFull = false; break; }
        }
        if (isFull) {
            for (let j = x; j < 19; ++j) {
                for (let y = 20; y < 30; ++y) { arena[y][j] = arena[y][j+1]; }
            }
            for (let y = 20; y < 30; ++y) { arena[y][19] = 0; }
            linesCleared++;
            x--; 
        }
    }

    if (linesCleared > 0) {
        score += linesCleared * scoreMultiplier * level;
        document.getElementById('score').innerText = score;
        level = Math.floor(score / 500) + 1;
        document.getElementById('level').innerText = level;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
    }
}

// ===========================
// 3. 게임 조작 및 흐름
// ===========================

function playerDrop() {
    if (!gameStarted) return;
    // 중력 방향으로 이동
    if (player.dir === 'top') player.pos.y++;
    else if (player.dir === 'right') player.pos.x--;
    else if (player.dir === 'left') player.pos.x++;
    
    if (collide(arena, player)) {
        // 충돌 시 한 칸 되돌리기
        if (player.dir === 'top') player.pos.y--;
        else if (player.dir === 'right') player.pos.x++;
        else if (player.dir === 'left') player.pos.x--;
        
        merge(arena, player);
        arenaSweep();
        playerReset(); 
    }
    dropCounter = 0;
}

function playerMove(dir) {
    if (!gameStarted) return;
    const oldX = player.pos.x;
    const oldY = player.pos.y;
    
    // 조작: 좌우 방향키는 항상 중력에 수직인 방향으로 이동 (수평 이동)
    if (player.dir === 'top') {
        player.pos.x += dir; 
    } else if (player.dir === 'right' || player.dir === 'left') {
        player.pos.y += dir; 
    }
    
    if (collide(arena, player)) {
        player.pos.x = oldX;
        player.pos.y = oldY;
    }
}

function playerHardDrop() {
    if (!gameStarted) return;
    while (!collide(arena, player)) {
        if (player.dir === 'top') player.pos.y++;
        else if (player.dir === 'right') player.pos.x--;
        else if (player.dir === 'left') player.pos.x++;
    }
    // 마지막 이동 되돌리기
    if (player.dir === 'top') player.pos.y--;
    else if (player.dir === 'right') player.pos.x++;
    else if (player.dir === 'left') player.pos.x--;

    merge(arena, player);
    arenaSweep();
    playerReset();
}

function getNextPiece() {
    if (bag.length === 0) {
        bag = piecesStr.split('').sort(() => Math.random() - 0.5);
    }
    return bag.pop();
}

function playerHold() {
    if (!gameStarted || !canHold) return;
    
    if (holdPieceType === null) {
        holdPieceType = player.type;
        playerReset(false); 
    } else {
        const temp = player.type;
        player.type = holdPieceType;
        holdPieceType = temp;
    }
    canHold = false;
    playerReset(false); 
}

// 블록 리셋 및 턴 변경 (핵심 수정: 시작 위치 조정)
function playerReset(changeTurn = true) {
    if (nextPieceType === null) nextPieceType = getNextPiece();
    
    player.type = nextPieceType;
    nextPieceType = getNextPiece();
    
    if (changeTurn) {
        turnIndex++;
        player.dir = directions[turnIndex % 3];
        canHold = true;
        document.getElementById('current-dir').innerText = player.dir.toUpperCase();
    }
    
    player.matrix = createPiece(player.type);
    
    // **시작 위치 (Spawn Point) 조정**
    if (player.dir === 'top') {
        player.pos.x = 24; 
        player.pos.y = 0; // Top Arm 최상단
    } else if (player.dir === 'right') {
        player.pos.x = 49; 
        player.pos.y = 24; // Right Arm 최우측 (Y축 중앙)
        rotate(player.matrix, 1); 
    } else if (player.dir === 'left') {
        player.pos.x = 0; 
        player.pos.y = 24; // Left Arm 최좌측 (Y축 중앙)
        rotate(player.matrix, 1); 
    }

    drawMiniCanvas(nextContext, nextPieceType);
    drawMiniCanvas(holdContext, holdPieceType);

    // **버그 수정:** 시작 위치가 블록을 바로 덮치는 경우만 게임 오버
    if (collide(arena, player)) {
        gameOver();
    }
}

// ===========================
// 4. 렌더링 및 UI
// ===========================

function draw() {
    context.fillStyle = '#000'; 
    context.fillRect(0, 0, GRID_COLS, GRID_ROWS); 
    
    // 배경 (벽 영역과 유효 영역 구분)
    for (let y = 0; y < GRID_ROWS; ++y) {
        for (let x = 0; x < GRID_COLS; ++x) {
            if (arena[y][x] === WALL) {
                context.fillStyle = '#111'; // 벽 영역
            } else if (arena[y][x] === 0) {
                context.fillStyle = '#1e1e1e'; // 유효 영역
            }
            if (arena[y][x] === WALL || arena[y][x] === 0) {
                context.fillRect(x, y, 1, 1);
            }
        }
    }

    // 고정된 블록 그리기
    drawMatrix(context, arena, {x: 0, y: 0}, 1);
    
    // 활성화된 블록 그리기
    if (gameStarted && !isGameOver) {
        drawMatrix(context, player.matrix, player.pos, 1);
    }
}

function drawMatrix(ctx, matrix, offset, scale) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value > 0) {
                ctx.fillStyle = colors[value];
                ctx.fillRect((x + offset.x) * scale, (y + offset.y) * scale, scale, scale);
                ctx.lineWidth = 0.05;
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.strokeRect((x + offset.x) * scale, (y + offset.y) * scale, scale, scale);
            }
        });
    });
}

function drawMiniCanvas(ctx, pieceType) {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, 4, 4);
    if (pieceType) {
        const matrix = createPiece(pieceType);
        const offsetX = (4 - matrix[0].length) / 2;
        const offsetY = (4 - matrix.length) / 2;
        drawMatrix(ctx, matrix, {x: offsetX, y: offsetY}, 1);
    }
}

function gameOver() {
    isGameOver = true;
    gameStarted = false;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over').style.display = 'flex';
}

function startGame() {
    overlay.style.display = 'none';
    isGameOver = false;
    gameStarted = true;
    restartGame(true); // 실제 게임 시작
}

function restartGame(isInitialStart = false) {
    if (!isInitialStart) {
        document.getElementById('game-over').style.display = 'none';
        isGameOver = false;
        gameStarted = true;
    }

    arena = createMatrix(GRID_COLS, GRID_ROWS, WALL); 
    score = 0;
    level = 1;
    turnIndex = 0;
    bag = [];
    nextPieceType = null;
    holdPieceType = null;
    canHold = true;
    dropInterval = 1000;
    
    document.getElementById('score').innerText = score;
    document.getElementById('level').innerText = level;
    document.getElementById('current-dir').innerText = 'TOP';
    drawMiniCanvas(holdContext, null);
    
    playerReset();
    update();
}

// ===========================
// 5. 게임 루프 및 이벤트
// ===========================

function update(time = 0) {
    if (!gameStarted) return;

    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        playerDrop();
    }

    draw();
    requestAnimationFrame(update);
}

// 이벤트 리스너
document.addEventListener('keydown', event => {
    if (!gameStarted || isGameOver) return;
    
    switch(event.keyCode) {
        case 37: playerMove(-1); break;
        case 39: playerMove(1); break;
        case 40: playerDrop(); break; 
        case 38: playerRotate(1); break;
        case 90: playerRotate(-1); break;
        case 32: playerHardDrop(); break;
        case 67: case 16: playerHold(); break; 
    }
});

startBtn.addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', () => restartGame(false));

// 초기 화면 렌더링
arena = createMatrix(GRID_COLS, GRID_ROWS, WALL);
draw();
</script>
</body>
</html>
