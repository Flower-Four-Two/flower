<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>3-Way T-Shape Tetris</title>
<style>
    /* (CSS는 이전 코드와 동일하게 적용합니다. 생략) */
    :root {
        --bg-color: #202028;
        --text-color: #fff;
        --accent-color: #ff00de;
        --ui-bg: #333;
    }
    body {
        background: var(--bg-color);
        color: var(--text-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        user-select: none;
    }

    h1 {
        margin: 0 0 15px 0;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 0 0 10px #fff, 0 0 20px var(--accent-color);
    }

    .main-container {
        display: flex;
        gap: 15px;
        position: relative;
    }

    .side-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 100px;
    }

    canvas {
        border: 2px solid #444;
        background-color: #000;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    }
    
    #main-canvas {
        /* 50x40 그리드 크기에 맞춰 설정 */
        width: 500px; 
        height: 400px;
    }

    .ui-box {
        background: var(--ui-bg);
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        border: 1px solid #555;
    }

    .label { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
    .value { font-size: 1.2rem; font-weight: bold; color: var(--accent-color); }
    .controls-info { font-size: 0.75rem; color: #888; text-align: left; }
    .mini-canvas { width: 80px; height: 80px; margin: 0 auto; display: block;}
    
    #game-over {
        display: none;
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85);
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
    }
    #game-over h2 { font-size: 2.5rem; color: red; margin-bottom: 10px; }

    #t-spin-msg {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 2rem; color: yellow; font-weight: bold;
        opacity: 0; transition: opacity 0.3s; pointer-events: none;
    }
</style>
</head>
<body>

    <h1>3-Way T-Shape Tetris (ㅗ)</h1>

    <div class="main-container">
        <div class="side-panel">
            <div class="ui-box">
                <div class="label">HOLD (C)</div>
                <canvas id="hold-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box">
                <div class="label">SCORE</div>
                <div id="score" class="value">0</div>
            </div>
            <div class="ui-box">
                <div class="label">LEVEL</div>
                <div id="level" class="value">1</div>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="main-canvas" width="500" height="400"></canvas>
            <div id="t-spin-msg">T-SPIN!</div>
            <div id="game-over">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="final-score">0</span></p>
                <button id="restart-btn">다시 시작</button>
            </div>
        </div>

        <div class="side-panel">
             <div class="ui-box">
                <div class="label">NEXT</div>
                <canvas id="next-canvas" class="mini-canvas" width="80" height="80"></canvas>
            </div>
            <div class="ui-box controls-info">
                <p>현재 방향: <span id="current-dir">TOP</span></p>
                <p>⬅️ ➡️ : 수평 이동 (중력 수직)</p>
                <p>⬇️ : 하드드롭 (중력 방향)</p>
                <p>⬆️ / Z : 회전</p>
                <p>Space : 바로 놓기</p>
                <p>C / Shift : 홀드</p>
            </div>
        </div>
    </div>

<script>
// ===========================
// 1. 초기 설정 및 상수 정의
// ===========================
const canvas = document.getElementById('main-canvas');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextContext = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold-canvas');
const holdContext = holdCanvas.getContext('2d');

// 게임판 정의 (50x40)
const GRID_COLS = 50;
const GRID_ROWS = 40;
const BLOCK_SIZE = 10; // 1블록당 10px

context.scale(BLOCK_SIZE, BLOCK_SIZE); // 캔버스 좌표계를 블록 단위로 변경
nextContext.scale(20, 20);
holdContext.scale(20, 20);

const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
const piecesStr = 'ILJOTSZ';

let isGameOver = false;
let score = 0;
let level = 1;
let bag = []; 
let nextPieceType = null;
let holdPieceType = null;
let canHold = true;
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

const directions = ['top', 'right', 'left']; 
let turnIndex = 0;
let currentDir = directions[0];

// -1: 벽(유효하지 않은 영역), 0: 빈 공간(유효한 영역)
const WALL = -1; 
let arena = createMatrix(GRID_COLS, GRID_ROWS, WALL);

const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    type: null,
    dir: 'top', 
};

// ===========================
// 2. 핵심 헬퍼 함수들
// ===========================

function createPiece(type) {
    // T, I, O, L, J, S, Z 블록 정의 (이전과 동일)
    switch (type) {
        case 'I': return [[0,0,0,0],[2,2,2,2],[0,0,0,0],[0,0,0,0]];
        case 'L': return [[0,0,5],[5,5,5],[0,0,0]];
        case 'J': return [[7,0,0],[7,7,7],[0,0,0]];
        case 'O': return [[6,6],[6,6]];
        case 'Z': return [[1,1,0],[0,1,1],[0,0,0]];
        case 'S': return [[0,3,3],[3,3,0],[0,0,0]];
        case 'T': return [[0,4,0],[4,4,4],[0,0,0]];
    }
}

// 50x40 매트릭스 생성 및 'ㅗ' 모양 유효 영역 설정 (0)
function createMatrix(w, h, fillValue) {
    const matrix = [];
    for (let y = 0; y < h; ++y) {
        matrix.push(new Array(w).fill(fillValue));
    }
    
    // 유효 영역 (0으로 채우기)
    // 1. Top Arm (10x40): X=20~29, Y=0~39 (실제 30 길이 + 10 코어)
    for (let y = 0; y < 40; ++y) {
        for (let x = 20; x < 30; ++x) {
            matrix[y][x] = 0;
        }
    }
    // 2. Right Arm (20x10): X=30~49, Y=30~39
    for (let y = 30; y < 40; ++y) {
        for (let x = 30; x < 50; ++x) {
            matrix[y][x] = 0;
        }
    }
    // 3. Left Arm (20x10): X=0~19, Y=30~39
    for (let y = 30; y < 40; ++y) {
        for (let x = 0; x < 20; ++x) {
            matrix[y][x] = 0;
        }
    }
    return matrix;
}

function rotate(matrix, dir) { /* ... 회전 로직 (이전과 동일) ... */
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
}

// 충돌 감지 (벽(-1)이나 다른 블록(>0)과의 충돌)
function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0) {
                const ax = x + o.x;
                const ay = y + o.y;

                // 맵 밖 충돌 (가장자리)
                if (ax < 0 || ax >= GRID_COLS || ay < 0 || ay >= GRID_ROWS) return true;
                
                // 벽(-1) 또는 다른 블록(>0) 충돌
                if (arena[ay][ax] === WALL || arena[ay][ax] > 0) return true;
            }
        }
    }
    return false;
}

function merge(arena, player) { /* ... 매트릭스 병합 로직 (이전과 동일) ... */
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                arena[y + player.pos.y][x + player.pos.x] = value;
            }
        });
    });
}

// 라인 클리어 로직 (방향별로 다름)
function arenaSweep() {
    let linesCleared = 0;

    // 1. Top Arm (X=20~29, Y=0~39) - 행(Row) 클리어 (중력: 아래)
    for (let y = 39; y >= 0; --y) {
        let isFull = true;
        for (let x = 20; x < 30; ++x) {
            if (arena[y][x] <= 0) { isFull = false; break; }
        }
        if (isFull) {
            // 행 삭제 및 블록 내리기
            for (let j = y; j > 0; --j) {
                for (let x = 20; x < 30; ++x) { arena[j][x] = arena[j-1][x]; }
            }
            for (let x = 20; x < 30; ++x) { arena[0][x] = 0; }
            linesCleared++;
            y++; 
        }
    }
    
    // 2. Right Arm (X=30~49, Y=30~39) - 열(Column) 클리어 (중력: 왼쪽 -> 밀기: 오른쪽)
    for (let x = 49; x >= 30; --x) {
        let isFull = true;
        for (let y = 30; y < 40; ++y) {
            if (arena[y][x] <= 0) { isFull = false; break; }
        }
        if (isFull) {
            // 열 삭제 및 블록 좌측으로 밀기
            for (let j = x; j > 30; --j) {
                for (let y = 30; y < 40; ++y) { arena[y][j] = arena[y][j-1]; }
            }
            for (let y = 30; y < 40; ++y) { arena[y][30] = 0; }
            linesCleared++;
            x++; 
        }
    }

    // 3. Left Arm (X=0~19, Y=30~39) - 열(Column) 클리어 (중력: 오른쪽 -> 밀기: 왼쪽)
    for (let x = 0; x < 20; ++x) {
        let isFull = true;
        for (let y = 30; y < 40; ++y) {
            if (arena[y][x] <= 0) { isFull = false; break; }
        }
        if (isFull) {
            // 열 삭제 및 블록 우측으로 밀기
            for (let j = x; j < 19; ++j) {
                for (let y = 30; y < 40; ++y) { arena[y][j] = arena[y][j+1]; }
            }
            for (let y = 30; y < 40; ++y) { arena[y][19] = 0; }
            linesCleared++;
            x--; 
        }
    }

    if (linesCleared > 0) { /* ... 점수 및 레벨 업데이트 (이전과 동일) ... */
        score += linesCleared * 100 * level;
        updateScoreBox();
        level = Math.floor(score / 500) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
    }
}

// ===========================
// 3. 렌더링 (유효 영역만 그리기)
// ===========================

function draw() {
    context.fillStyle = '#000'; 
    context.fillRect(0, 0, GRID_COLS, GRID_ROWS); 
    
    // 배경 (WALL 영역 어둡게, 유효 영역 밝게)
    for (let y = 0; y < GRID_ROWS; ++y) {
        for (let x = 0; x < GRID_COLS; ++x) {
            if (arena[y][x] === WALL) {
                context.fillStyle = '#111'; // 벽 영역 (검은색 배경)
            } else if (arena[y][x] === 0) {
                context.fillStyle = '#1e1e1e'; // 유효 영역 (어두운 회색)
            }
            if (arena[y][x] === WALL || arena[y][x] === 0) {
                context.fillRect(x, y, 1, 1);
            }
        }
    }

    // 고정된 블록 그리기
    drawMatrix(context, arena, {x: 0, y: 0}, 1);
    
    // 활성화된 블록 그리기
    drawMatrix(context, player.matrix, player.pos, 1);
}

// 행렬 그리기 유틸리티 (이전과 동일)
function drawMatrix(ctx, matrix, offset, scale) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value > 0) {
                ctx.fillStyle = colors[value];
                ctx.fillRect((x + offset.x) * scale, (y + offset.y) * scale, scale, scale);
                ctx.lineWidth = 0.05;
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.strokeRect((x + offset.x) * scale, (y + offset.y) * scale, scale, scale);
            }
        });
    });
}

// ===========================
// 4. 플레이어 조작 및 게임 흐름 (방향별 조작 적용)
// ===========================

function playerDrop() { /* ... 드롭 로직 (이전과 동일) ... */
    if (player.dir === 'top') player.pos.y++;
    else if (player.dir === 'right') player.pos.x--;
    else if (player.dir === 'left') player.pos.x++;
    
    if (collide(arena, player)) {
        if (player.dir === 'top') player.pos.y--;
        else if (player.dir === 'right') player.pos.x++;
        else if (player.dir === 'left') player.pos.x--;
        
        merge(arena, player);
        arenaSweep();
        playerReset(); 
    }
    dropCounter = 0;
}

function playerMove(dir) { /* ... 수평 이동 로직 (이전과 동일) ... */
    const oldX = player.pos.x;
    const oldY = player.pos.y;
    
    if (player.dir === 'top') {
        player.pos.x += dir; 
    } else if (player.dir === 'right' || player.dir === 'left') {
        player.pos.y += dir; 
    }
    
    if (collide(arena, player)) {
        player.pos.x = oldX;
        player.pos.y = oldY;
    }
}

function playerHardDrop() { /* ... 하드 드롭 로직 (이전과 동일) ... */
    while (!collide(arena, player)) {
        if (player.dir === 'top') player.pos.y++;
        else if (player.dir === 'right') player.pos.x--;
        else if (player.dir === 'left') player.pos.x++;
    }
    if (player.dir === 'top') player.pos.y--;
    else if (player.dir === 'right') player.pos.x++;
    else if (player.dir === 'left') player.pos.x--;

    merge(arena, player);
    arenaSweep();
    playerReset();
}

function playerRotate(dir) { /* ... 회전 로직 (이전과 동일) ... */
    const oldX = player.pos.x;
    const oldY = player.pos.y;
    
    rotate(player.matrix, dir);
    if (collide(arena, player)) {
        rotate(player.matrix, -dir);
        player.pos.x = oldX;
        player.pos.y = oldY;
    }
}

function getNextPiece() { /* ... 7-Bag 시스템 로직 (이전과 동일) ... */
    if (bag.length === 0) {
        bag = piecesStr.split('').sort(() => Math.random() - 0.5);
    }
    return bag.pop();
}

function playerHold() { /* ... 홀드 로직 (이전과 동일) ... */
    if (!canHold) return;
    
    if (holdPieceType === null) {
        holdPieceType = player.type;
        playerReset(false); 
    } else {
        const temp = player.type;
        player.type = holdPieceType;
        holdPieceType = temp;
        player.matrix = createPiece(player.type);
    }
    canHold = false;
    // 블록 위치 재설정은 playerReset에서 처리
    playerReset(false); 
}

// 블록 리셋 및 턴 변경 (다음 방향으로 순환)
function playerReset(changeTurn = true) {
    if (nextPieceType === null) nextPieceType = getNextPiece();
    
    player.type = nextPieceType;
    nextPieceType = getNextPiece();
    
    if (changeTurn) {
        turnIndex++;
        player.dir = directions[turnIndex % 3]; // 방향 순환
        canHold = true;
        document.getElementById('current-dir').innerText = player.dir.toUpperCase();
    }
    
    player.matrix = createPiece(player.type);
    
    // 시작 위치 및 블록 회전 (중요!)
    if (player.dir === 'top') {
        player.pos.x = 24; player.pos.y = 0; // Top Arm 중앙
    } else if (player.dir === 'right') {
        player.pos.x = 49; player.pos.y = 34; // Right Arm 최우측
        rotate(player.matrix, 1); // 90도 회전된 형태로 시작
    } else if (player.dir === 'left') {
        player.pos.x = 0; player.pos.y = 34; // Left Arm 최좌측
        rotate(player.matrix, 1); // 90도 회전된 형태로 시작
    }

    drawMiniCanvas(nextContext, nextPieceType);
    drawMiniCanvas(holdContext, holdPieceType);

    // 게임 오버 체크
    if (collide(arena, player)) {
        gameOver();
    }
}

function gameOver() { /* ... 게임 오버 로직 (이전과 동일) ... */
    isGameOver = true;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over').style.display = 'flex';
}

function restartGame() { /* ... 게임 재시작 로직 (이전과 동일) ... */
    arena = createMatrix(GRID_COLS, GRID_ROWS, WALL); 
    score = 0;
    level = 1;
    turnIndex = 0;
    bag = [];
    nextPieceType = null;
    holdPieceType = null;
    isGameOver = false;
    dropInterval = 1000;
    updateScoreBox();
    drawMiniCanvas(holdContext, null);
    document.getElementById('game-over').style.display = 'none';
    playerReset();
    update();
}

function updateScoreBox() { /* ... 점수 업데이트 로직 (이전과 동일) ... */
    document.getElementById('score').innerText = score;
    document.getElementById('level').innerText = level;
}

// 게임 루프
function update(time = 0) { /* ... 게임 루프 로직 (이전과 동일) ... */
    if (isGameOver) return;

    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        playerDrop();
    }

    draw();
    requestAnimationFrame(update);
}

// 키보드 입력
document.addEventListener('keydown', event => { /* ... 키 입력 로직 (이전과 동일) ... */
    if (isGameOver) return;
    
    switch(event.keyCode) {
        case 37: playerMove(-1); break; // Left 
        case 39: playerMove(1); break;  // Right
        case 40: playerDrop(); break; // Down (소프트 드롭)
        case 38: playerRotate(1); break; // Up (Rotate CW)
        case 90: playerRotate(-1); break; // Z (Rotate CCW)
        case 32: playerHardDrop(); break; // Space (하드 드롭)
        case 67: case 16: playerHold(); break; // C or Shift (홀드)
    }
});
document.getElementById('restart-btn').addEventListener('click', restartGame);

// 보조 캔버스 그리기 함수
function drawMiniCanvas(ctx, pieceType) {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 0, 4, 4);
    if (pieceType) {
        const matrix = createPiece(pieceType);
        const offsetX = (4 - matrix[0].length) / 2;
        const offsetY = (4 - matrix.length) / 2;
        drawMatrix(ctx, matrix, {x: offsetX, y: offsetY}, 1);
    }
}

// 게임 시작
playerReset();
update();
</script>
</body>
</html>
